algorithm for finding library/require(mypkg):

find SYMBOL_FUNCTION_CALL library or require
foreach of them:
    go down 1 row, get parent, call it p, call this row i1
    get last row with parent p, call that i2.
    between i and i2 (non-inclusive) is a row with either SYMBOL or STR_CONST whose text is (?) mypkg, 'mypkg', or "mypkg"

this could accidentally catch library(help=mypkg), but probably not. you could detect this.


algorithm for finding length of functions:


#go down through the df, 
#every time you see a SYMBOL, make a note of it (call it s)
#(ignore the next row? and comments, and whitespace)
#then if the next row is LEFT_ASSIGN (<-) or EQ_ASSIGN (=)
#(ignore the next row? and comments and whitespace)
#if next row is FUNCTION, bingo, the previous SYMBOL row has the info you need
#(name of function and length in lines)
# oops, that won't work with "=" functions
# for "=" functions (and maybe generally?):
# look at the parent id of the row you are on (FUNCTION) and then
# look ahead until the parent is greater than that (ignoring 0 for comments).
# you've gone one row too far, so back up 1 and line2 of the row you are on is the last
# line of the function, line1 of "s" is the first line of it, and
# the name of the function is s$text, and the number of lines is lastline - firstline
# or 1, whichever is higher.
an exception is a function at the very end of a file. you won't find another 
row with a higher parent, but the last row is the last line of the function.


